---
title: "MySQLのインデックスってどれくらい効果があるの？試してみた"
emoji: "🧐"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["mysql", "database", "index"]
published: false
---

# はじめに
MySQLのインデックスについて調べていて、仕組みはわかったけど実際にどれくらい効果があるんだ？と思ったので、実際に試してみました。
以下にリポジトリを公開しているので、ぜひお手元で試してみてください！！
https://github.com/mshr0969/mysql-index-test

MYSQLのインデックスについては以下の記事が参考になるかと！

# データ準備
## テーブル作成
今回は以下のようなシンプルなテーブルを作成しました。salaryはランダムな数値、isDeletedは削除フラグです。
```sql
CREATE TABLE IF NOT EXISTS employees
(
    id        VARCHAR(36) PRIMARY KEY,
    name      VARCHAR(255) NOT NULL,
    salary    INT,
    isDeleted BOOLEAN DEFAULT FALSE
);
```
## データ挿入
10,000件のランダムなデータを挿入します。1件だけ既知の値を入れて、残りはランダムな値を入れています。
:::details データ挿入のSQL

```sql
DELIMITER //
CREATE PROCEDURE insert_random_employees()
BEGIN
    DECLARE i INT DEFAULT 1;

    -- 知っているUUIDを指定してレコードを挿入
INSERT INTO employees (id, name, salary, isDeleted)
VALUES ('123e4567-e89b-12d3-a456-426614174000', -- 既知のUUID
        'John Doe', -- 固定の名前
        75000, -- 固定の給与
        FALSE);
-- isDeletedはFALSE固定

-- 残りのレコードをランダムなUUIDで挿入
WHILE i <= 9999
        DO
            -- ランダムに名前を選ぶ (プレフィックスとサフィックスを組み合わせる)
            INSERT INTO employees (id, name, salary, isDeleted)
            VALUES (UUID(), -- ランダムなUUID
                    CONCAT(
                            ELT(FLOOR(1 + (RAND() * 8)), -- ランダムにプレフィックスを選ぶ
                                'John', 'Jane', 'Mike', 'Lisa', 'Chris', 'Sara', 'Tom', 'Emma'
                            ),
                            ' ',
                            ELT(FLOOR(1 + (RAND() * 8)), -- ランダムにサフィックスを選ぶ
                                'Smith', 'Doe', 'Johnson', 'Brown', 'Wilson', 'Moore', 'Taylor', 'Anderson'
                            )
                    ),
                    FLOOR(50000 + (RAND() * 50000)), -- ランダムな給与 (50000 ~ 100000)
                    ELT(FLOOR(1 + (RAND() * 2)), TRUE, FALSE) -- ランダムでTRUEまたはFALSEを選ぶ
                   );
            SET i = i + 1;
END WHILE;
END//
DELIMITER ;

-- ストアドプロシージャの実行
CALL insert_random_employees();
```

:::message
最初に既知の値を入れるとインデックスの効果が適切にわからないのでは？というのはあるかもしれませんが、あくまでインデックスの効果を確認するためのテストなので多目に見てください。
:::

# 検証してみる
実際にインデックスを作成して、クエリの実行時間を比較していきます！
データベースを立ち上げて、SQL文を実行していきます。詳しくはリポジトリのREADMEを参照してください。
## 数値を単一で検索
### インデックスなしの場合
profillingを有効にして、計測していきます。
```shell
mysql> SET profiling = 1;
```
給料が75000の人を検索します。ちょうど1人だけヒットしました。
```shell
mysql> SELECT * FROM employees WHERE salary = 75000;
+--------------------------------------+---------+--------+-----------+
| id                                   | name    | salary | isDeleted |
+--------------------------------------+---------+--------+-----------+
| 123e4567-e89b-12d3-a456-426614174000 | John Do |  75000 |         0 |
+--------------------------------------+---------+--------+-----------+
```

以下のコマンドで実行時間を確認できます。これを見ると、0.01396350秒かかっていることがわかります。
```shell
mysql> SHOW PROFILES;
+----------+------------+----------------------------------------------+
| Query_ID | Duration   | Query                                        |
+----------+------------+----------------------------------------------+
|        1 | 0.01396350 | SELECT * FROM employees WHERE salary = 75000 |
+----------+------------+----------------------------------------------+
```

### インデックスありの場合
次に、salaryにインデックスを作成します。
```shell
mysql> CREATE INDEX idx_salary ON employees (salary);
```
同様に、給料が75000の人を検索します。実行時間を確認すると、0.00111600秒となりました。インデックスを作成することで、約10倍の速度で検索ができてきます！！
```shell
mysql> SELECT * FROM employees WHERE salary = 75000;
+----------+------------+----------------------------------------------+
| Query_ID | Duration   | Query                                        |
+----------+------------+----------------------------------------------+
|        1 | 0.01396350 | SELECT * FROM employees WHERE salary = 75000 |
|        2 | 0.05041375 | CREATE INDEX idx_name ON employees (salary)  |
|        3 | 0.00111600 | SELECT * FROM employees WHERE salary = 75000 |
+----------+------------+----------------------------------------------+
```
:::message
Query_IDが2のCREATE INDEXを見ると、インデックスの作成って意外と(？)時間かかるんだな〜というのがわかりますね
:::

## 数値を範囲指定で検索
先ほどのインデックスを一旦削除して、範囲指定(比較演算子、BETWEEN)で検索してみます。
### 比較演算子
```shell
mysql> SELECT *
    -> FROM employees
    -> WHERE salary >= 70000
    ->   AND salary <= 75000;
```
### BETWEEN
```shell
mysql> SELECT *
    -> FROM employees
    -> WHERE salary BETWEEN 70000
    ->           AND 75000;
```

### 結果
上から、
1. インデックス無しの比較演算子
2. インデックス無しのBETWEEN
3. インデックス作成
4. インデックスありの比較演算子
5. インデックスありのBETWEEN

```shell
+----------+------------+------------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                                  |
+----------+------------+------------------------------------------------------------------------+
|        1 | 0.01571775 | SELECT * FROM employees WHERE salary >= 70000 AND salary <= 75000      |
|        2 | 0.00981050 | SELECT * FROM employees WHERE salary BETWEEN 70000 AND 75000           |
|        3 | 0.04685125 | CREATE INDEX idx_name ON employees (salary)                            |
|        4 | 0.02437675 | SELECT * FROM employees WHERE salary >= 70000 AND salary <= 90000      |
|        5 | 0.02490375 | SELECT * FROM employees WHERE salary BETWEEN 70000 AND 90000           |
+----------+------------+------------------------------------------------------------------------+
5 rows in set, 1 warning (0.00 sec)
```
あれ、、？インデックスを作成したほうが遅くね？
:::message
```shell
mysql> EXPLAIN SELECT * FROM employees WHERE salary BETWEEN 70000 AND 90000;
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
| id | select_type | table     | partitions | type  | possible_keys | key      | key_len | ref  | rows | filtered | Extra                 |
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
|  1 | SIMPLE      | employees | NULL       | range | idx_name      | idx_name | 5       | NULL |    1 |   100.00 | Using index condition |
+----+-------------+-----------+------------+-------+---------------+----------+---------+------+------+----------+-----------------------+
```
::::
